### 索引执行情况

- 每个字段代表的意思：

- id: 查询的标识符
- select_type: 查询的类型。
- table: 查询涉及的表。
- partitions: 查询涉及的分区。
- type: 访问类型。
- possible_keys: 可能使用的索引。
- key: 实际使用的索引。
- key_len: 索引长度。
- ref: 使用的列或常量。
- rows: 估计需要读取的行数。
- filtered: 过滤的百分比。
- Extra: 额外的信息。


### 索引下推
```text
索引下推,5.6之后才有的特性

explain 查看extra:using index condition

没有索引下推,先查索引,查到一个之后,回表,在继续根据索引过滤
有索引下推,之后,不包含在索引的完整行数据不会被检索

有效果的情况:where条件可以在索引层面过滤时


```


### 为什么走了索引之后,查询还很慢

```text
表 test
mysql组合索引 index_ab(a,b)
select * from test where a = 1 and b = c order by id  
```

联合索引的结构图

![示例图片](./WX20241101-015027@2x.png "图片标题")


- 可以看到，在这个索引上，数据存储顺序是：按照a值递增，对于a值相同的情况，按照b值递增。
- 因此上面这个语句的执行流程就是：从索引ab上，取最右的一个记录，取出主键值ID_Z；
- 根据ID_Z到主键索引上取整行记录，作为结果集的第一行；  
- -m在索引ab上取上一个记录的左边相邻的记录；
- 每次取到主键id值，再到主键索引上取到整行记录，添加到结果集的下一行；
- 重复步骤3、4，直到遍历完整个索引。
- 可以看到，这个流程中并不涉及到排序操作。我们也可以用explain语句来验证这个结论。
- 图2是这个语句的explain的结果，可以看到，Extra字段中没有Using filesort字样，说明这个语句执行过程中，不需要用到排序。

### 总结

```text
1.InnoDB索引树以任意一个叶节点为起始点，可以向左或向右遍历；
2.如果语句需要的order by顺序刚好可以利用索引树的单向遍历，就可以避免排序操作。
3.如果是查询出来的数据列很少,不会走file sort
4.如果查询出来的数据量很大,会走file sort,解决方案,组合索引加多个id,然后排序统一递增或者统一递减
```

### 聚簇索引,非聚簇索引

- 一个表只有一个聚簇索引,可以有多个唯一索引
- 主键索引一定是唯一索引
- 聚簇索引索引不一定是主键索引,如果一个表没有主键索引,会用非空的唯一索引作为聚簇索引,如果没有唯一索引,会生成一个名为gen_clust_index隐藏聚簇索引

### 数据库表数据很大,查询还是很快,为什么

- 数据库的配置
- 走了索引
- 行数据不大,相当于一个高表
- 一条sql只会走一个索引
- 加了索引之后排序,要么都升序,要么都降序
- 